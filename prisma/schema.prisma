// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  SUPER_ADMIN
  COMPANY_OWNER
  PROPERTY_MANAGER
  TENANT
  CONTRACTOR
  ACCOUNTANT
}

enum LeaseStatus {
  DRAFT
  ACTIVE
  EXPIRED
  TERMINATED
  RENEWED
}

enum PropertyType {
  APARTMENT
  HOUSE
  COMMERCIAL
  OFFICE
  WAREHOUSE
}

enum MaintenanceStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum MaintenancePriority {
  LOW
  MEDIUM
  HIGH
  EMERGENCY
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

enum PaymentType {
  RENT
  DEPOSIT
  FEE
  MAINTENANCE
  UTILITY
}

enum IssueCategory {
  PLUMBING
  ELECTRICAL
  APPLIANCE
  HVAC
  STRUCTURAL
  PEST_CONTROL
  CLEANING
  SECURITY
  LANDSCAPING
  PAYMENT
  GENERAL
}

enum IssueSeverity {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ContractorStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum WorkflowTrigger {
  MAINTENANCE_REQUEST_CREATED
  PAYMENT_OVERDUE
  LEASE_EXPIRING
  CONTRACTOR_ASSIGNED
  ISSUE_ESCALATED
}

enum WorkflowAction {
  ASSIGN_CONTRACTOR
  SEND_NOTIFICATION
  ESCALATE_ISSUE
  CREATE_PAYMENT_REQUEST
  SEND_EMAIL
  UPDATE_STATUS
}

enum NotificationType {
  MAINTENANCE_REQUEST
  PAYMENT_REMINDER
  LEASE_EXPIRING
  CONTRACTOR_ASSIGNED
  WORK_COMPLETED
  SYSTEM_ALERT
}

enum NotificationStatus {
  PENDING
  SENT
  READ
  FAILED
}

// Multi-tenant company model
model Company {
  id          String   @id @default(cuid())
  name        String
  subdomain   String   @unique
  logo        String?
  address     String?
  phone       String?
  email       String?
  website     String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users       User[]
  properties  Property[]
  leases      Lease[]
  payments    Payment[]
  maintenanceRequests MaintenanceRequest[]
  invitations Invitation[]
  contractors Contractor[]
  workflowRules WorkflowRule[]
  notifications Notification[]
  
  @@map("companies")
}

// User model with multi-tenant support
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  phone         String?
  avatar        String?
  password      String
  role          UserRole  @default(TENANT)
  isActive      Boolean   @default(true)
  emailVerified DateTime?
  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Multi-tenant relationship
  companyId     String
  company       Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Relations
  accounts      Account[]
  sessions      Session[]
  managedProperties Property[] @relation("PropertyManager")
  leases        Lease[]
  maintenanceRequests MaintenanceRequest[]
  sentInvitations Invitation[] @relation("InvitationSender")
  receivedInvitations Invitation[] @relation("InvitationReceiver")
  paymentsMade  Payment[] @relation("PaymentPayer")
  paymentsReceived Payment[] @relation("PaymentReceiver")
  notifications Notification[]
  assignedMaintenanceRequests MaintenanceRequest[] @relation("AssignedContractor")

  @@map("users")
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// Property management models
model Property {
  id          String      @id @default(cuid())
  name        String
  address     String
  city        String
  state       String
  zipCode     String
  type        PropertyType
  bedrooms    Int?
  bathrooms   Float?
  squareFeet  Int?
  description String?     @db.Text
  images      String[]
  amenities   String[]
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Multi-tenant relationship
  companyId   String
  company     Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Property manager relationship
  managerId   String?
  manager     User?       @relation("PropertyManager", fields: [managerId], references: [id])

  // Relations
  units       Unit[]
  leases      Lease[]
  maintenanceRequests MaintenanceRequest[]

  @@map("properties")
}

model Unit {
  id          String   @id @default(cuid())
  number      String
  floor       Int?
  bedrooms    Int?
  bathrooms   Float?
  squareFeet  Int?
  rent        Float
  deposit     Float
  isAvailable Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Property relationship
  propertyId  String
  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  // Relations
  leases      Lease[]

  @@unique([propertyId, number])
  @@map("units")
}

// Lease management models
model Lease {
  id            String      @id @default(cuid())
  startDate     DateTime
  endDate       DateTime
  monthlyRent   Float
  deposit       Float
  status        LeaseStatus @default(DRAFT)
  terms         String?     @db.Text
  notes         String?     @db.Text
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Multi-tenant relationship
  companyId     String
  company       Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Property and unit relationships
  propertyId    String
  property      Property    @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  unitId        String
  unit          Unit        @relation(fields: [unitId], references: [id], onDelete: Cascade)

  // Tenant relationship
  tenantId      String
  tenant        User        @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Relations
  payments      Payment[]
  maintenanceRequests MaintenanceRequest[]

  @@map("leases")
}

// Maintenance management models
model MaintenanceRequest {
  id          String              @id @default(cuid())
  title       String
  description String              @db.Text
  priority    MaintenancePriority @default(MEDIUM)
  status      MaintenanceStatus   @default(PENDING)
  category    String?
  aiCategory  IssueCategory?      // AI-generated category
  aiSeverity  IssueSeverity?      // AI-determined severity
  estimatedCost Float?
  actualCost    Float?
  scheduledDate DateTime?
  completedDate DateTime?
  images        String[]
  notes         String?           @db.Text
  aiAnalysis    Json?             // Store AI analysis results
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Multi-tenant relationship
  companyId   String
  company     Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Property relationship
  propertyId  String
  property    Property            @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  // Lease relationship (optional, for tenant-specific requests)
  leaseId     String?
  lease       Lease?              @relation(fields: [leaseId], references: [id])

  // Requester relationship
  requesterId String
  requester   User                @relation(fields: [requesterId], references: [id])

  // Assigned contractor relationship
  assignedContractorId String?
  assignedContractor   User?   @relation("AssignedContractor", fields: [assignedContractorId], references: [id])

  // Contractor assignment (if using Contractor model)
  contractorId String?
  contractor   Contractor? @relation(fields: [contractorId], references: [id])

  @@map("maintenance_requests")
}

// Payment management models
model Payment {
  id            String        @id @default(cuid())
  amount        Float
  type          PaymentType
  status        PaymentStatus @default(PENDING)
  description   String?
  dueDate       DateTime?
  paidDate      DateTime?
  stripePaymentIntentId String?
  metadata      Json?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Multi-tenant relationship
  companyId     String
  company       Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Lease relationship
  leaseId       String?
  lease         Lease?        @relation(fields: [leaseId], references: [id])

  // Payer and receiver relationships
  payerId       String
  payer         User          @relation("PaymentPayer", fields: [payerId], references: [id])
  
  receiverId    String
  receiver      User          @relation("PaymentReceiver", fields: [receiverId], references: [id])

  @@map("payments")
}

// Invitation system for multi-tenant onboarding
model Invitation {
  id          String    @id @default(cuid())
  email       String
  role        UserRole
  token       String    @unique
  isUsed      Boolean   @default(false)
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Multi-tenant relationship
  companyId   String
  company     Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Sender relationship
  senderId    String
  sender      User      @relation("InvitationSender", fields: [senderId], references: [id])

  // Receiver relationship (optional, set when invitation is accepted)
  receiverId  String?
  receiver    User?     @relation("InvitationReceiver", fields: [receiverId], references: [id])

  @@map("invitations")
}

// Contractor management model
model Contractor {
  id          String           @id @default(cuid())
  name        String
  email       String
  phone       String?
  address     String?
  website     String?
  description String?          @db.Text
  specialties IssueCategory[]  // Areas of expertise
  rating      Float?           // Average rating (0-5)
  totalJobs   Int              @default(0)
  completedJobs Int            @default(0)
  status      ContractorStatus @default(ACTIVE)
  hourlyRate  Float?
  isPreferred Boolean          @default(false)
  licenseNumber String?
  insuranceInfo Json?          // Insurance details
  availability  Json?          // Availability schedule
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Multi-tenant relationship
  companyId   String
  company     Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Relations
  maintenanceRequests MaintenanceRequest[]
  workflowRules       WorkflowRule[]

  @@unique([email, companyId])
  @@map("contractors")
}

// Workflow automation rules
model WorkflowRule {
  id          String          @id @default(cuid())
  name        String
  description String?         @db.Text
  isActive    Boolean         @default(true)
  trigger     WorkflowTrigger
  conditions  Json            // Conditions for rule activation
  actions     Json            // Actions to execute
  priority    Int             @default(0)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  // Multi-tenant relationship
  companyId   String
  company     Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Target contractor (for auto-assignment rules)
  contractorId String?
  contractor   Contractor?    @relation(fields: [contractorId], references: [id])

  @@map("workflow_rules")
}

// Notification system
model Notification {
  id          String             @id @default(cuid())
  title       String
  message     String             @db.Text
  type        NotificationType
  status      NotificationStatus @default(PENDING)
  data        Json?              // Additional notification data
  readAt      DateTime?
  sentAt      DateTime?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  // Multi-tenant relationship
  companyId   String
  company     Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Recipient relationship
  userId      String
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}
